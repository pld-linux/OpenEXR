--- OpenEXR-1.1.0/Imath/ImathEuler.h.orig	2004-02-04 23:12:12.000000000 +0100
+++ OpenEXR-1.1.0/Imath/ImathEuler.h	2004-04-01 22:58:58.565948968 +0200
@@ -394,7 +394,7 @@
 {
     setOrder(p); 
     if ( l == XYZLayout ) setXYZVector(v);
-    else { x = v.x; y = v.y; z = v.z; }
+    else { this->x = v.x; this->y = v.y; this->z = v.z; }
 }
 
 template<class T>
@@ -418,7 +418,7 @@
 {
     setOrder(p);
     if ( l == XYZLayout ) setXYZVector(Vec3<T>(xi,yi,zi));
-    else { x = xi; y = yi; z = zi; }
+    else { this->x = xi; this->y = yi; this->z = zi; }
 }
 
 template<class T>
@@ -453,7 +453,7 @@
 	// Extract the first angle, x.
 	// 
 
-	x = Math<T>::atan2 (M[j][i], M[k][i]);
+	this->x = Math<T>::atan2 (M[j][i], M[k][i]);
 
 	//
 	// Remove the x rotation from M, so that the remaining
@@ -462,7 +462,7 @@
 	//
 
 	Vec3<T> r (0, 0, 0);
-	r[i] = (_parityEven? -x: x);
+	r[i] = (_parityEven? -(this->x): this->x);
 
 	Matrix44<T> N;
 	N.rotate (r);
@@ -476,8 +476,8 @@
 	//
 
 	T sy = Math<T>::sqrt (N[j][i]*N[j][i] + N[k][i]*N[k][i]);
-	y = Math<T>::atan2 (sy, N[i][i]);
-	z = Math<T>::atan2 (N[j][k], N[j][j]);
+	this->y = Math<T>::atan2 (sy, N[i][i]);
+	this->z = Math<T>::atan2 (N[j][k], N[j][j]);
     }
     else
     {
@@ -485,7 +485,7 @@
 	// Extract the first angle, x.
 	// 
 
-	x = Math<T>::atan2 (M[j][k], M[k][k]);
+	this->x = Math<T>::atan2 (M[j][k], M[k][k]);
 
 	//
 	// Remove the x rotation from M, so that the remaining
@@ -494,7 +494,7 @@
 	//
 
 	Vec3<T> r (0, 0, 0);
-	r[i] = (_parityEven? -x: x);
+	r[i] = (_parityEven? -(this->x): this->x);
 
 	Matrix44<T> N;
 	N.rotate (r);
@@ -508,8 +508,8 @@
 	//
 
 	T cy = Math<T>::sqrt (N[i][i]*N[i][i] + N[i][j]*N[i][j]);
-	y = Math<T>::atan2 (-N[i][k], cy);
-	z = Math<T>::atan2 (-N[j][i], N[j][j]);
+	this->y = Math<T>::atan2 (-N[i][k], cy);
+	this->z = Math<T>::atan2 (-N[j][i], N[j][j]);
     }
 
     if (!_parityEven)
@@ -517,9 +517,9 @@
 
     if (!_frameStatic)
     {
-	T t = x;
-	x = z;
-	z = t;
+	T t = this->x;
+	this->x = this->z;
+	this->z = t;
     }
 }
 
@@ -535,7 +535,7 @@
 	// Extract the first angle, x.
 	// 
 
-	x = Math<T>::atan2 (M[j][i], M[k][i]);
+	this->x = Math<T>::atan2 (M[j][i], M[k][i]);
 
 	//
 	// Remove the x rotation from M, so that the remaining
@@ -544,7 +544,7 @@
 	//
 
 	Vec3<T> r (0, 0, 0);
-	r[i] = (_parityEven? -x: x);
+	r[i] = (_parityEven? -(this->x): this->x);
 
 	Matrix44<T> N;
 	N.rotate (r);
@@ -555,8 +555,8 @@
 	//
 
 	T sy = Math<T>::sqrt (N[j][i]*N[j][i] + N[k][i]*N[k][i]);
-	y = Math<T>::atan2 (sy, N[i][i]);
-	z = Math<T>::atan2 (N[j][k], N[j][j]);
+	this->y = Math<T>::atan2 (sy, N[i][i]);
+	this->z = Math<T>::atan2 (N[j][k], N[j][j]);
     }
     else
     {
@@ -564,7 +564,7 @@
 	// Extract the first angle, x.
 	// 
 
-	x = Math<T>::atan2 (M[j][k], M[k][k]);
+	this->x = Math<T>::atan2 (M[j][k], M[k][k]);
 
 	//
 	// Remove the x rotation from M, so that the remaining
@@ -573,7 +573,7 @@
 	//
 
 	Vec3<T> r (0, 0, 0);
-	r[i] = (_parityEven? -x: x);
+	r[i] = (_parityEven? -(this->x): this->x);
 
 	Matrix44<T> N;
 	N.rotate (r);
@@ -584,8 +584,8 @@
 	//
 
 	T cy = Math<T>::sqrt (N[i][i]*N[i][i] + N[i][j]*N[i][j]);
-	y = Math<T>::atan2 (-N[i][k], cy);
-	z = Math<T>::atan2 (-N[j][i], N[j][j]);
+	this->y = Math<T>::atan2 (-N[i][k], cy);
+	this->z = Math<T>::atan2 (-N[j][i], N[j][j]);
     }
 
     if (!_parityEven)
@@ -593,9 +593,9 @@
 
     if (!_frameStatic)
     {
-	T t = x;
-	x = z;
-	z = t;
+	T t = this->x;
+	this->x = this->z;
+	this->z = t;
     }
 }
 
@@ -608,7 +608,7 @@
     Vec3<T> angles;
 
     if ( _frameStatic ) angles = (*this);
-    else angles = Vec3<T>(z,y,x);
+    else angles = Vec3<T>(this->z, this->y, this->x);
 
     if ( !_parityEven ) angles *= -1.0;
 
@@ -651,7 +651,7 @@
     Vec3<T> angles;
 
     if ( _frameStatic ) angles = (*this);
-    else angles = Vec3<T>(z,y,x);
+    else angles = Vec3<T>(this->z, this->y, this->x);
 
     if ( !_parityEven ) angles *= -1.0;
 
@@ -693,7 +693,7 @@
     angleOrder(i,j,k);
 
     if ( _frameStatic ) angles = (*this);
-    else angles = Vec3<T>(z,y,x);
+    else angles = Vec3<T>(this->z, this->y, this->x);
 
     if ( !_parityEven ) angles.y = -angles.y;
 
@@ -781,9 +781,9 @@
 template<class T>
 const Euler<T>& Euler<T>::operator= (const Euler<T> &euler)
 {
-    x = euler.x;
-    y = euler.y;
-    z = euler.z;
+    this->x = euler.x;
+    this->y = euler.y;
+    this->z = euler.z;
     _initialAxis = euler._initialAxis;
     _frameStatic = euler._frameStatic;
     _parityEven	 = euler._parityEven;
@@ -794,9 +794,9 @@
 template<class T>
 const Euler<T>& Euler<T>::operator= (const Vec3<T> &v)
 {
-    x = v.x;
-    y = v.y;
-    z = v.z;
+    this->x = v.x;
+    this->y = v.y;
+    this->z = v.z;
     return *this;
 }
 
--- OpenEXR-1.1.0/exrmakepreview/makePreview.cpp.orig	2004-02-07 01:43:40.000000000 +0100
+++ OpenEXR-1.1.0/exrmakepreview/makePreview.cpp	2004-04-01 23:02:42.341929848 +0200
@@ -82,7 +82,7 @@
     if (x > 1)
 	x = 1 + knee (x - 1, 0.184874f);
 
-    return (unsigned char) (clamp (pow (x, 0.4545f) * 84.66f, 0.f, 255.f));
+    return (unsigned char) (clamp (pow (x, 0.4545f) * 84.66f, 0.0, 255.0));
 }
 
 
